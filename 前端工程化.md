### node.js

#### Node.js是什么

- node是JS代码运行环境，在JSV8引擎上运行
- node是基于V8引擎来执行js代码的程序
- V8引擎可以被嵌入到任何C++程序中，只要C++程序嵌入了V8引擎，就可以执行JS代码
- node 不是 使用 js 来编写的，使用 JS\C\C++ 编写的

![nodejs](C:\Users\admin\Desktop\系统笔记\img_前端工程化\nodejs.png)

------

#### 浏览器和Node.js架构区别

![浏览器和Node.js架构区别](C:\Users\admin\Desktop\系统笔记\img_前端工程化\浏览器和Node.js架构区别.png)

------

#### Node.js架构

![Node.js架构](C:\Users\admin\Desktop\系统笔记\img_前端工程化\Node.js架构.png)

------

#### node 应用场景

![应用场景](C:\Users\admin\Desktop\系统笔记\img_前端工程化\应用场景.png)

------

#### node 安装

- 直接安装，不需要配置环境变量
- 命令 node 文件名 ，执行文件

![安装](C:\Users\admin\Desktop\系统笔记\img_前端工程化\安装.png)

------

#### Node的版本工具

- n mac

- nvm 支持window

  - https://github.com/coreybutler/nvm-windows
  - 安装 nvm，安装其他版本node， use 版本号 切换（以管理员身份运行cmd）

- vscode（重启后） 终端 以 cmd 运行

  - ![vscode_cmd](C:\Users\admin\Desktop\系统笔记\img_前端工程化\vscode_cmd.png)

  - 修改 vscode 默认终端为 cmd

    - 选择默认配置文件

    ![配置cmd](C:\Users\admin\Desktop\系统笔记\img_前端工程化\配置cmd.png)

------

![Node的版本工具](C:\Users\admin\Desktop\系统笔记\img_前端工程化\Node的版本工具.png)

------

#### 版本管理工具：n

![版本管理工具：n](C:\Users\admin\Desktop\系统笔记\img_前端工程化\版本管理工具：n.png)

------

#### JavaScript代码执行

![JavaScript代码执行](C:\Users\admin\Desktop\系统笔记\img_前端工程化\JavaScript代码执行.png)

------

#### Node的REPL

![Node的REPL](C:\Users\admin\Desktop\系统笔记\img_前端工程化\Node的REPL.png)

------

#### Node程序传递参数

- 命令 传递 node a.js num=10

- 代码 获取 process.argv

  - ```js
    const arg1 = process.argv[2]
    const arg2 = process.argv[3]
    
    console.log(arg1, arg2)
    ```

![Node程序传递参数](C:\Users\admin\Desktop\系统笔记\img_前端工程化\Node程序传递参数.png)

------

#### 为什么叫argv呢

![为什么叫argv呢](C:\Users\admin\Desktop\系统笔记\img_前端工程化\为什么叫argv呢.png)

------

#### node 命令 交互

- 命令 node
- 输入 想要执行的代码
- 两次 Ctrl c 退出
- cls 清空命令行

![node命令交互](C:\Users\admin\Desktop\系统笔记\img_前端工程化\node命令交互.png)

#### Node的输出

- https://nodejs.org/dist/latest-v16.x/docs/api/console.html

![Node的输出](C:\Users\admin\Desktop\系统笔记\img_前端工程化\Node的输出.png)

------

#### 常见的全局对象

```js
// 1.类似于window的全局对象
console.log(global)


// 2.特殊的全局对象
// __dirname当前的文件所在的目录结构(重要)
console.log(__dirname)
// __filename当前目录+文件名称
console.log(__filename)


// 3.模块化(重要)
console.log(module)
console.log(exports)
console.log(require)


// 4.常见的全局对象(了解)
console.log(process)
console.log(process.argv)


// 5.定时器方法
setTimeout(() => {
  console.log("setTimeout")
}, 2000);
setInterval(() => {
  console.log("setInterval")
}, 3000)

// 额外补充: Immediate: 立即/立刻
setImmediate(() => {
  console.log("setImmediate")
})

// 额外执行函数
process.nextTick(() => {
  console.log("nextTick")
})


// 6.全局对象
console.log(global)
console.log(globalThis)
console.log(global === globalThis)
```

![常见的全局对象](C:\Users\admin\Desktop\系统笔记\img_前端工程化\常见的全局对象.png)

![常见的全局对象2](C:\Users\admin\Desktop\系统笔记\img_前端工程化\常见的全局对象2.png)

------

#### 特殊的全局对象

![特殊的全局对象](C:\Users\admin\Desktop\系统笔记\img_前端工程化\特殊的全局对象.png)

------

#### node 的 global对象

![global对象](C:\Users\admin\Desktop\系统笔记\img_前端工程化\global对象.png)

------

#### global和window的区别

![global和window的区别](C:\Users\admin\Desktop\系统笔记\img_前端工程化\global和window的区别.png)

------

### JS模块化开发

#### 什么是模块化

- 模块化把一个大文件，拆分为多个小文件，每个文件有独立的作用域，通过导出导入使用文件的代码；解决命名冲突、解决一个文件代码太多，混乱，不方便查找、维护

  - 没有模块化，通过自执行函数，来创建作用域，避免命名冲突
  - 最常用的是 ES标准 的 ESModule 

- js 使用的是 ESModule 

  - 通过 export 导出
  - import 导入

- node.js 使用的是 CommonJS 规范

  - 通过 exports 、module.exports 导出
  - require 导入

- node中 使用 CommonJS 规范（CJS）来 实现模块化。CJS 是一种规范

  - 通过 exports、module.exports 导出

    - 通常 使用 module.exports 导出
    - exports === module.exports 是同一个对象
      - 所以 导出 exports 就是 导出 module.exports
      - exports 是一个固定对象
      - module是一个类，类有一个exports 对象，这个exports 默认指向 固定对象exports ，如果 通过 module.exports=｛｝来导出，那么 module 中的 exports对象，指向这个新创建的对象，不再指向 exports 固定对象
    - 结论: Node导出的本质是在导出 module.exports 对象
      - module.exports 导出 优先级高于 exports ，覆盖 exports 
    - 因为是同一个对象，所以使用 exports 导出也可以
      - 之所以有一个 exports ，是为了 符合 CommonJS 的 规范
      - 实际 exports 没用，导出 exports 就是 导出 module.exports
      - 为什么使用  module.exports 导出，因为node 中是本质通过 module.exports 导出，exports ，只是为了 符合 CommonJS 的 规范 加的

    - 图解，导出1、导出2，导出的是同个对象，引入的也是这个对象

    ![导出](C:\Users\admin\Desktop\系统笔记\img_前端工程化\导出.png)

    - 图解，导出的是同个对象，引入的也是这个对象

    ![导出2](C:\Users\admin\Desktop\系统笔记\img_前端工程化\导出2.png)

    - 图解，exports 始终是空对象，module.exports = 一个对象，因为 module.exports 优先级高，所以引入的是 module.exports = 的对象

    ![导出3](C:\Users\admin\Desktop\系统笔记\img_前端工程化\导出3.png)

    ![导出4](C:\Users\admin\Desktop\系统笔记\img_前端工程化\导出4.png)

    ```js
    const name = "foo"
    const age = 18
    function sayHello() {
      console.log("sayHello")
    }
    
    // 导出1.在开发中使用的很少
    exports.name = name
    exports.age = age
    exports.sayHello = sayHello
    
    // 导出2
    // 结论: Node导出的本质是在导出module.exports对象
    module.exports.name = name
    module.exports.age = age
    module.exports.sayHello = sayHello
    
    // console.log(exports === module.exports)
    
    // 导出3.开发中常见的写法
    module.exports = {
      name,
      age,
      sayHello
    }
    // 导出3 对应的 导入：
    const foo = require("./foo.js")
    console.log(foo.name, 'main')
    ```

  - require 导入

    - 导入的都是通过引用赋值
    - 所以 导入者，都可以修改，导致 导出文件中的代码被改变，所有的导入引入的代码被改变

```js
// ECMAScript没有推出来自己的模块化方案: 社区的模块化 ：CommonJS/AMD/CMD
// ES6(ES2015)推出自己的模块化方案: ESModule
```

```js
// 导出1
let name = "bar"
exports.name = name
exports.name

// 导出2；exports 是一个对象
exports.UTIL_NAME = UTIL_NAME
exports.formatCount = formatCount
exports.formatDate = formatDate

// 导入1.直接获取导入的对象, 从对象中获取属性；对象名字 util 是自定义的
const util = require("./util.js")
console.log(util.UTIL_NAME)
console.log(util.formatCount())
console.log(util.formatDate())

// 导入2.导入对象之后, 直接对其进行解构
const { 
  UTIL_NAME,
  formatCount, 
  formatDate 
} = require("./util.js")
console.log(UTIL_NAME)
console.log(formatCount())
console.log(formatDate())
```

![什么是模块化](C:\Users\admin\Desktop\系统笔记\img_前端工程化\什么是模块化.png)

------

#### 模块化的历史

![模块化的历史](C:\Users\admin\Desktop\系统笔记\img_前端工程化\模块化的历史.png)

------

#### 没有模块化带来的问题

![没有模块化带来的问题](C:\Users\admin\Desktop\系统笔记\img_前端工程化\没有模块化带来的问题.png)

------

#### CommonJS规范和Node关系

![CommonJS规范和Node关系](C:\Users\admin\Desktop\系统笔记\img_前端工程化\CommonJS规范和Node关系.png)

------

#### exports导出

![exports导出](C:\Users\admin\Desktop\系统笔记\img_前端工程化\exports导出.png)

------

#### module.exports导出

![module.exports导出](C:\Users\admin\Desktop\系统笔记\img_前端工程化\module.exports导出.png)

------

#### 改变代码发生了什么

![改变代码发生了什么](C:\Users\admin\Desktop\系统笔记\img_前端工程化\改变代码发生了什么.png)

------

#### require细节

- .js 文件后缀可以省略
- 如果导入的是，文件夹下面的 index.js ，文件名 index 也可以 省略

```js
// 1.根据路径导入自己编写模块
const utils = require("./utils")
console.log(utils.formatDate())
const foo = require("./foo")


// 2.导入node提供给内置模块
const path = require("path")
const http = require("http")
const http = require("fs")
console.log(path, http)


// 3.情况三: 名称不是路径, 也不是一个内置模块;

// 去 当前文件目录中 的 node_modules 文件夹 中查找，有就能找到，可以自己创建文件，写入代码
// 当前文件目录中 没有 node_modules，去上层 目录中找

// npm 安装库的源码，都在 node_modules 文件夹中

const why = require("why")
console.log(why) // 找不到

const axios = require("axios")
console.log(axios) // 安装axios库，或者在 node_modules 手动创建axios文件，就能找到
```

![require细节](C:\Users\admin\Desktop\系统笔记\img_前端工程化\require细节.png)

------

![require细节2](C:\Users\admin\Desktop\系统笔记\img_前端工程化\require细节2.png)

------

![require细节3](C:\Users\admin\Desktop\系统笔记\img_前端工程化\require细节3.png)

------

#### 模块的加载过程

- 第一次引入就会执行，多次引入，也只执行一次，执行的是第一次的引入
- 循环引用，A引入B和C，B引入D；执行：A\B\\D\C
- 会把B和B引入的文件执行到底，执行到最后一个引入D，再去执行C

![模块的加载过程](C:\Users\admin\Desktop\系统笔记\img_前端工程化\模块的加载过程.png)

------

#### CommonJS规范缺点

- 加载模块是 同步的

![CommonJS规范缺点](C:\Users\admin\Desktop\系统笔记\img_前端工程化\CommonJS规范缺点.png)

------

#### AMD规范

![AMD规范](C:\Users\admin\Desktop\系统笔记\img_前端工程化\AMD规范.png)

------

#### AMD-require.js的使用

- https://github.com/requirejs/requirejs

![require.js的使用](C:\Users\admin\Desktop\系统笔记\img_前端工程化\require.js的使用.png)

------

#### CMD规范

![CMD规范](C:\Users\admin\Desktop\系统笔记\img_前端工程化\CMD规范.png)

------

#### CMD-seajs使用

- https://github.com/seajs/seajs

![seajs使用](C:\Users\admin\Desktop\系统笔记\img_前端工程化\seajs使用.png)

------

#### 认识 ES Module

- 前端 使用 模块化

  - 浏览器 支持 ES Module ，直接使用 ES Module  

  - 浏览器 不支持 ES Module ，借助 webpack 模块化打包工具
    - webpack 下，可以一个文件使用 ES Module，另一个文件使用 CommonJS 

- ES Module

  - 通过 export 导出
  - import 导入
  - 默认 严格模式

  ```js
  const name = "why"
  const age = 18
  function sayHello() {
    console.log("sayHello")
  }
  
  // 导出 export ;{} 不是对象，只能写key
  export {
    name,
    age,
    sayHello
  }
  // 导入 import；导入、导出，都写在 {} 内
  // 注意事项一: 在浏览器中直接使用esmodule时, 必须在文件后加上后缀名.js
  import { name, age, sayHello } from "./foo.js"
  ```

- 多种导出、导入 方式

  - as 
    - 别名
  - *
    - 所有
  - 都通过 ｛｝导出、导入

```js
// 1.导出方式一: 
export {
  name,
  age,
  sayHello
}
// 2.导出方式二: 导出时给标识符起一个别名
export {
  name as fname, // 导出 的 name 别名为 fname，导入时使用 fname，避免命名冲突
  age,
  sayHello
}
// 3.导出方式三: 定义的同时导出
export const name = "why"
export const age = 18
export function sayHello() {
  console.log("sayHello")
}
export class Person {}

// 1.导入方式一: 
import { name, age, sayHello } from "./foo.js"

// 2.导入方式二: 导入时给标识符起别名；导出时为name，导入时 给name 一个别名 fname
import { name as fname, age, sayHello } from "./foo.js"

// 3.导入时可以给整个模块起别名；* 整个模块导入进来，并给这个模块一个别名 foo，直接使用foo.属性 即可
import * as foo from "./foo.js"
```

- 导入 多层
  - 把所有的导入到 index（入口文件），使用时，只导入 index 文件

```js
// 没有优化的 导入、导出
import { formatCount, formatDate } from './format.js'
import { parseLyric } from './parse.js'

export {
  formatCount,
  formatDate,
  parseLyric
}
```

- export import 结合 使用
  - 推荐使用 优化一

```js
// utils/index.js
// 优化一: 结合 使用 export import；引入导出一起
export { formatCount, formatDate } from './format.js'
export { parseLyric } from './parse.js'

// 优化二: 先导入，再导出所有；引用处main.js，直接使用 format.js、parse.js 文件内 导出的名字（parseLyric、formatCount、formatDate）即可
export * from './format.js'
export * from './parse.js'

// main.js
// 在需要使用的文件 main.js，导入，从 utils/index.js 导入
import { 
  formatCount, 
  formatDate, 
  parseLyric 
} from './utils/index.js'

console.log(formatCount())
```

- default  默认导出
  - 只需要导出 一个的时候
  - 一个模块只能有一个默认导出
  - 导入的时候，不用从｛｝ 内导入，随便写一个自定义名字，就可以

```js
// 1.默认导出:
// 1.1. 定义函数
function parseLyric() {
  return ["歌词"]
}

// 1.2.默认导出，只需要导出 一个的时候
export default parseLyric


// 2.1默认导出.定义标识符直接作为默认导出
export default function() {
  return ["新歌词"]
}

// 默认导出 对应的 导入,不需要 {},也不需要 和导出的名字对应，parseLyric 是自定义的名字，可以 随便写个名字 aaa bbb 等，一般是 导入的文件名字
import parseLyric from "./parse_lyric.js"
console.log(parseLyric())
```

- import 导入

  - import  声明语法
    - 导入时，必须放在 顶层，文件的第一行
    - `import { name, age, sayHello } from "./foo.js"`
  - import  函数
    - 这个 import  函数 是异步的，并且 返回 一个 promise，通过 then 获取
    - 逻辑代码中 只能使用 import 函数 ，在 到达需要条件时，通过 import 引入

  ```js
  // 1.import  声明语法
  import { name, age, sayHello } from "./foo.js"
  console.log(name, age)
  
  
  // 2.import函数的使用
  let flag = true
  if (flag) {
    // 不允许在逻辑代码中编写import导入声明语法, 只能写到js代码顶层
    // import { name, age, sayHello } from "./foo.js" 
  
    // 如果确实是逻辑成立时, 才需要导入某个模块
    // import函数的使用
    
    // 普通代码：
    const importPromise = import("./foo.js")
    importPromise.then(res => {
      console.log(res.name, res.age)
    })
    // 优化代码：
    import("./foo.js").then(res => {
      console.log(res.name, res.age)
    })
  }
  ```

- 通过 script 标签 导入，设置 type = module,把导入的JS文件当做一个模块加载
  - 在我们打开对应的html时, 如果html中有使用模块化的代码, 那么必须开启一个服务来打开 

```js
  <script src="./foo.js" type="module"></script>
  <script src="./main.js" type="module"></script>
```

![认识 ES Module](C:\Users\admin\Desktop\系统笔记\img_前端工程化\认识 ES Module.png)

------

#### 案例代码结构组件

![案例代码结构组件](C:\Users\admin\Desktop\系统笔记\img_前端工程化\案例代码结构组件.png)

------

#### exports关键字

![exports关键字](C:\Users\admin\Desktop\系统笔记\img_前端工程化\exports关键字.png)

------

#### import关键字

![import关键字](C:\Users\admin\Desktop\系统笔记\img_前端工程化\import关键字.png)

------

#### export和import结合使用

![export和import结合使用](C:\Users\admin\Desktop\系统笔记\img_前端工程化\export和import结合使用.png)

------

#### default用法

![default用法](C:\Users\admin\Desktop\系统笔记\img_前端工程化\default用法.png)

------

#### import函数

![import函数](C:\Users\admin\Desktop\系统笔记\img_前端工程化\import函数.png)

------

#### import meta

- import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。
  - 它包含了这个模块的信息，比如说这个模块的URL；
  - 在ES11（ES2020）中新增的特性；

#### ES Module的解析流程

- https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/
- 由浏览器解析代码后：
- 1-构建
  - 根据JS文件的路径，下载JS文件，解析成模块记录
- 2-实例化，这个过程，没有执行代码
  - 解析这个 模块记录中，有哪些导出和导入
    - 导入
      - 如果有其他的导入，再下载导入的文件，解析成模块记录
      - 直到没有导入
    - 如果 模块记录中有 导出
      - 把 导出的数据 放入 模块环境记录（新创建的）（分配自己的内存空间，存放导出的数据）
      - 这时 模块环境记录中的 导出数据 没有 value，name：''
- 3-运行
  - 执行代码，给 模块环境记录 中的 导出数据 进行 赋值 value
  - name:'foo'
  - 并且把所有的 模块环境记录 放入 一个新的 模块环境记录
  - 在导入的时候，找到这个 新的 环境记录，从中取值使用
- 先根据JS路径下载文件，然后解析文件，只解析 导出、导入，不执行代码
  - 一个是解析导入，如果还有导入，根据JS路径下载文件，然后解析文件，直到没有导入
  - 再是解析导出，如果有导出，分配内存，存放导出的数据
  - 因为，只解析 导出、导入，不执行代码，所以数据只有key，没有value
  - 然后执行代码，给内存中的数据进行赋值
  - 最终，在 导入 取值使用 的时候，从刚刚的内存中，取值使用
    - 前面的 解析导入 只是解析 导出、导入，不执行代码
    - 这里的 导入是执行代码
    - 在执行代码的时候，代码顺序是，赋值在上，取值在下
    - 所以，在使用 导入的数据时，已经赋值了，才能取到值

![module流程](C:\Users\admin\Desktop\系统笔记\img_前端工程化\module流程.png)

![ES Module的解析流程](C:\Users\admin\Desktop\系统笔记\img_前端工程化\ES Module的解析流程.png)

------

#### 阶段一：构建阶段

![阶段一：构建阶段](C:\Users\admin\Desktop\系统笔记\img_前端工程化\阶段一：构建阶段.png)

------

#### 阶段二和三：实例化阶段 – 求值阶段

![阶段二和三：实例化阶段 – 求值阶段](C:\Users\admin\Desktop\系统笔记\img_前端工程化\阶段二和三：实例化阶段 – 求值阶段.png)

------

### 包管理工具

#### 代码共享方案 

#### 包管理工具npm 

#### npm的配置文件 

- 记录项目信息 package.json
- `npm init -y` 默认生成 package.json
- 

#### 常见的配置文件 

##### 常见的属性

##### 常见的属性2

- main 设置入口文件
- 当加载包的时候，先读取包代码中的 package.json 找到 mian 对应的入口文件 加载

##### 常见的属性3

- scripts 脚本命令
- key是命令名称 `build`
- value是命令执行的代码  `webpack  index.js`
- dependencies
  - 是指定无论开发环境还是生成环境都需要依赖的包
  - `npm install webpack`
- devDependencies
  - 在生成环境是不需要的
  - 比如webpack、babel
  - 通过 `npm install webpack --save-dev`
    - `npm install webpack -D`
    - 将它安装到 devDependencies 中
- peerDependencies
  - 当前库需要依赖其他库才能使用

#### 依赖的版本管理 



##### 常见属性 

#### npm install 命令 

- 把 程序exe文件加入环境变量内，即可命令行启动

- 全局安装，加入环境变量
  - `npm install webpack -g`
- 局部安装：安装到 node_modules，不加入环境变量
  - `npm install webpack`

#### 项目安装 

#### npm install 原理 

- npm i 
- 先去查找有没有 lock： package-lock.json 文件
  - 有，根据 lock 文件中的依赖关系（A依赖B），去检查 是否和当下现在最新的包的依赖是否一致（A依赖B和C），不一致，重新从仓库中下载，解压到 node_modules 中，重新生成 lock 文件
    - 一致，从缓存中查找包，没有找到就从仓库中下载，有从缓存中拿到，解压放入 node_modules 中
  - 没有，把包以及包依赖的其他包，根据包名从 registry 仓库中下载，解压到 node_modules 中
    - 因为没有lock，在完成安装后，自动生成 lock 文件
- 如果电脑中有2个项目，使用到同个包
  - 那么第二个项目使用的包，不会重新从仓库下载，而是从电脑的缓存中查找包，拿来解压到 node_modules 中使用，第一个项目下载包后，会放在电脑的缓存中
  - 通过算法找到同个包的缓存，算法会生成包的标识符，最终通过标识符来找同个包
  - 这个包的标识符，保存在 package-lock.json 文件中，根据这个标识符从缓存中查找，如果没有找到再从仓库中下载
  - package.json 如果分享项目，是不带 node_modules 的，如果版本是向上兼容的，本来是^0.2.1版本；别人拿到项目后，npm i ，下载的包的版本，0.3.2版本，使用了新特性后；又把项目分享回去了，那么0.2.1版本就使用不了0.3.2版本的新特性，只能升级包
  - 所以，为了统一包版本， package-lock.json 中保存着，明确安装的版本，而非向上兼容版本
    - 别人安装的时候，就会根据  package-lock.json  安装明确的版本，避免多人协作的项目，出现包版本混乱的问题
- package-lock.json 
  - 保存包的标识符，用于从缓存中查找包，而非从仓库下载包
  - 记录着明确的包版本，避免多人项目，出现包版本混乱
  - 记录着包的依赖关系，必须有B包，才能够使用A包

#### npm install 原理图解析 

#### package-lock.json 

#### npm其他命令 

- https://docs.npmjs.com/cli-documentation/cli 

#### yarn工具

- 全局安装，不需要配置环境变量

```js
npm i yarn -g
yarn add axios
```

#### cnpm工具

- 访问不了 registry 仓库
- 安装 cnpm，并且将cnpm设置为淘宝的镜像 

```js
// 查看 npm 镜像
npm config get registry
```

- 不修改 npm，下载 cnpm ，修改cnpm

```js
// 安装 cnpm，并且将cnpm设置为淘宝的镜像
cnpm install -g cnpm --registry=https://registry.npm.taobao.org
// 设置cnpm镜像为淘宝的镜像
cnpm config set registry https://registry.npm.taobao.org
// 查看 cnpm 镜像
cnpm config get registry # https://r.npm.taobao.org/
```

#### npx工具

- 执行命令
  - 先去当前目录中查找命令对应的包
  - 找不到，再去环境变量中查找
- 全局安装一个版本
- 局部项目安装另一个版本的包
- 如果在局部项目的当前目录执行命令，在当前目录中，没有查找到命令对应的包，又不希望去环境变量查找，希望去当前目录的子目录中查找，使用 npx 命令
  - 这样就可以在局部使用局部版本的包
  - 而不是使用全部版本的包
  - 避免用错，包的版本
    - npx 命令
  - npx 是 npm 自带的，直接使用
- 在package.json中的scripts命令中的自定义命令也可以
  - 先去 本项目的node_modules查找，找不到，再去环境变量查找

#### 局部命令的执行 

#### npm发布自己的包 

- 首先 npm init -y 生成 package.json 文件

```js
{
  "name": "c_event_store", 包名字
  "version": "1.0.0", 版本
  "description": "WeChat Mini Programs status Management Library", 简介
  "main": "index.js",入口文件
  "scripts": { 
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["WeChat Mini Programs status Management Library", "WeChat Mini Programs", "Mini Programs status"], 搜索关键词
  "author": "lyc",作者
  "license": "MIT"开源协议
}
```

- 终端登录 npm login
- homepage 主页
- url 仓库

![发布包](C:\Users\admin\Desktop\系统笔记\img_前端工程化\发布包.png)

------

- npm publish 发布命令
- 更新包，修改代码后，修改版本号，npm publish 

#### 什么是pnpm呢

- 原因包工具，如果有多个项目，每个项目都有依赖的包，启动每个项目，那么每个项目都要下载对应的包，这些包中有很多重复的，没有必要重复下载，占有电脑内存

#### 硬链接和软连接的概念 

- 硬链接 指向电脑 磁盘中的真实数据
- 软连接 指向 硬链接所在的路径，硬链接 指向电脑 磁盘中的真实数据

硬链接和软连接操作系统中的抽象-图片

#### 硬链接和软连接的演练 

#### pnpm到底做了什么呢

#### pnpm创建非扁平的 node_modules 目录 

#### pnpm的安装和使用 

#### pnpm的存储store

